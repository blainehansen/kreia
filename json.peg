// special whitespace sensitive tokens!!
// %indent, %deindent, %newline = %__indent, %__deindent, %__newline

%Whitespace = /\s+/, anywhere
%Colon = ':'
%Comma = ','
%LeftBrace = '{'
%RightBrace = '}'
%LeftBracket = '['
%RightBracket = ']'
%Num = /[0-9]+/
%Primitive = ['null', 'undefined', 'true', 'false']
%Str = /"(?:\\[\"\\]|[^\n\"\\])*"/

// making tokens from other token definitions, with a slice
%directive = '@' %ident ';', slice = 1:-1

// if we're making escapable sequences easy
// %Str = @__enclosed(/\"|\'/,  escape_character = '/', discard_enclosure = true) // \ would be the default escape sequence
// other things to worry about:
// keywords (or other "matching rules could be shorter and different")


%string = @__enclosed('"', escape_character = '\\')
%multi_comment = @__enclosed_open_close('/*', '*/', stackable = true, includes_newlines = true)
%comment = @__enclosed_open_close('//', '\n', includes_newlines = false)

%postgres_string = @__enclosed('$' %ident* '$', includes_newlines = true)

%indent, %deindent, %newline = @__significant_whitespace
// doing it this way allows the parser to take over and process the stuff itself
// basically, after %raw_block_begin is encountered, all newlines and indents and stuff will be handled as raw,
// and then once a %deindent is actually given to the parser, that means that everything is back to normal?
%indent, %deindent, %newline, %raw_block_begin = @__significant_whitespace_with_raw_block('|"')

json_entity =
	| array
	| object
	| atomicEntity

@separated_by_commas[$rule] = ($rule (%Comma $rule)*)?

array =
	%LeftBracket
	@separated_by_commas[json_entity]
	%RightBracket

object =
	%LeftBrace
	@separated_by_commas[%Str %Colon, json_entity]
	%RightBrace

atomic_entity =
	| %Str
	| %Num
	| %Primitive

