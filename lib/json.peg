%Whitespace = /\s+/, ignore: true
%Colon = ':'
%Comma = ','
%LeftBrace = '{'
%RightBrace = '}'
%LeftBracket = '['
%RightBracket = ']'
%Num = /[0-9]+/
%Primitive = ['null', 'undefined', 'true', 'false']
%Str = /"(?:\\[\"\\]|[^\n\"\\])*"/

// making tokens from other token definitions, with a slice
%directive = '@' %ident ';', slice: 1..-1

// here are a bunch of token macros
// if we're making escapable sequences easy
%Str = %%enclosed('/\"|\'/', escape_character: '/', discard_enclosure: true) // \ would be the default escape sequence
// other things to worry about:
// keywords (or other "matching rules could be shorter and different")

%string = %%enclosed('"', escape_character = '\\')
%multi_comment = %%enclosed_open_close('/*', '*/', stackable = true, includes_newlines = true)
%comment = %%enclosed_open_close('//', '\n', includes_newlines = false)

// this is a virtual lexer useage directive
// only one per state is allowed
&{ %indent, %deindent, %newline } = &significant_whitespace
// doing it this way allows the parser to take over and process the stuff itself
// basically, after %raw_block_begin is encountered, all newlines and indents and stuff will be handled as raw,
// and then once a %deindent is actually given to the parser, that means that everything is back to normal?
&{ %space, %indent, %deindent, %newline, %raw_block_begin, %raw_block_str, %raw_block_interpolated_ident, %raw_block_interpolation_begin } = &significant_whitespace_with_raw_block
	'|"',
	ident_interpolator: '$' %ident,
	interpolation_begin_: '${',


#some_state =
	{ %special, %tokens } = &my_virtual_lexer
	%normal = 'normal'


block_string = %%raw_block(
	'|"',
	ident_interpolation = %%raw_block_capture('$' %ident),
	expression_interpolation = %%raw_block_capture_open_close('${', '}', expression_stem)
)


%block_string_any = /(\\$|[^\\\$\n])+/

%dollar_ident = '$' %ident

%dollar_expression_open = '${', push: #main
%right_brace = '}', pop: true

block_string_line = (%block_string_any | %dollar_ident | %dollar_expression_open expression_stem %right_brace)+

block_string_lines =
	@many_separated[
		%block_string_line | %indent block_string_lines %deindent,
		%newline,
	]


block_string =
	%block_string_begin
	%indent
	block_string_lines
	%deindent




json_entity =
	| array
	| object
	| atomicEntity

@separated_by_commas[$rule] = $rule (%Comma $rule)*

array =
	%LeftBracket
	@separated_by_commas[json_entity]
	%RightBracket

object =
	%LeftBrace
	@separated_by_commas[%Str %Colon, json_entity]
	%RightBrace

atomic_entity =
	| %Str
	| %Num
	| %Primitive





%strstart = '`', push: #lit
%ident = /\w+/,
%lbrace = '{', push: #main
%rbrace =   '}', pop: true
%colon = ':'
%space = /\s+/

#lit =
	%interp = '${', push: #main
	%escape = /\\./
	%strend = '`', pop: true
	%const = '/(?:[^$`]|\\$(?!\\{))+/'


expression =
	| %ident
	| %lbrace %space (%ident %colon %space %expression)* %space %rbrace
	|
		%strstart
		*
			| %const | (%escape %strend)
			| %interp expression %rbrace
		%strend


@customizable_postgres_string<%%sigil = %ident>[$open, $close] =
	$open %%sigil $close
	*
		| %escape $open
		| %any
	$open %%sigil $close

postgres_string<%%sigil = %ident> =
	%dollar %%sigil %dollar
	*
		| %not_dollar
		| %escape $dollar
	%dollar %%sigil %dollar


html_tag<%%tag_name = %html_tag_ident> =
	%open_angle %%tag_name (%ident %eq string)*

	| %slash %close_angle
	| %close_angle (text | html_tag)* %open_angle %%tag_name %slash %close_angle

