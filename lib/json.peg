// special whitespace sensitive tokens!!
// %indent, %deindent, %newline = %__indent, %__deindent, %__newline

%Whitespace = /\s+/, anywhere
%Colon = ':'
%Comma = ','
%LeftBrace = '{'
%RightBrace = '}'
%LeftBracket = '['
%RightBracket = ']'
%Num = /[0-9]+/
%Primitive = ['null', 'undefined', 'true', 'false']
%Str = /"(?:\\[\"\\]|[^\n\"\\])*"/

// making tokens from other token definitions, with a slice
%directive = '@' %ident ';', slice = 1:-1

// if we're making escapable sequences easy
// %Str = @__enclosed(/\"|\'/,  escape_character = '/', discard_enclosure = true) // \ would be the default escape sequence
// other things to worry about:
// keywords (or other "matching rules could be shorter and different")


%string = @__enclosed('"', escape_character = '\\')
%multi_comment = @__enclosed_open_close('/*', '*/', stackable = true, includes_newlines = true)
%comment = @__enclosed_open_close('//', '\n', includes_newlines = false)

%postgres_string = @__enclosed('$' %ident* '$', includes_newlines = true)

%indent, %deindent, %newline = @__significant_whitespace
// doing it this way allows the parser to take over and process the stuff itself
// basically, after %raw_block_begin is encountered, all newlines and indents and stuff will be handled as raw,
// and then once a %deindent is actually given to the parser, that means that everything is back to normal?
%indent, %deindent, %newline, %raw_block_begin = @__significant_whitespace_with_raw_block('|"')

block_string = @__raw_block(
	'|"',
	ident_interpolation = @__raw_block_capture('$' %ident),
	expression_interpolation = @__raw_block_capture_open_close('${', '}', expression_stem)
)


%block_string_any = /(\\$|[^\\\$\n])+/

%dollar_ident = '$' %ident

%dollar_expression_open = '${'
%right_brace = '}'

block_string_line = (%block_string_any | %dollar_ident | %dollar_expression_open expression_stem %right_brace)+

block_string_lines =
	@many_separated[
		%block_string_line | %indent block_string_lines %deindent,
		%newline,
	]


block_string =
	%block_string_begin
	%indent
	block_string_lines
	%deindent




json_entity =
	| array
	| object
	| atomicEntity

@separated_by_commas[$rule] = ($rule (%Comma $rule)*)?

array =
	%LeftBracket
	@separated_by_commas[json_entity]
	%RightBracket

object =
	%LeftBrace
	@separated_by_commas[%Str %Colon, json_entity]
	%RightBrace

atomic_entity =
	| %Str
	| %Num
	| %Primitive















html_tag<%tag_name = %html_tag_ident> =
	%open_angle %tag_name (%ident %eq string)*

	| %slash %close_angle
	| %close_angle (text | html_tag)* %open_angle %tag_name %slash %close_angle

